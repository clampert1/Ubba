<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UBBA DANCE BATTLE — Final</title>
<style>
body {
  margin: 0;
  background: #000;
  color: #fff;
  font-family: Arial, Helvetica, sans-serif;
  overflow: hidden;
}
.game {
  display: flex;
  justify-content: space-between;
  width: 100%;
  height: 100vh;
  box-sizing: border-box;
  padding: 40px;
}
.side {
  width: 46%;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.top {
  display: flex;
  gap: 20px;
  justify-content: center;
  margin-bottom: 80px;
}
.static {
  width: 80px;
  height: 80px;
  border-radius: 10px;
  background: #222;
  color: #fff;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 4px solid #444;
  transition: all 0.12s;
}
.static.left { border-color: #4ecdc4; }
.static.down { border-color: #ffe66d; }
.static.up { border-color: #ff6b6b; }
.static.right { border-color: #ff9f1c; }
.static.active {
  background: #0f0;
  color: #000;
  transform: scale(1.08);
  box-shadow: 0 0 18px rgba(0,255,0,.6);
}
.static.fail {
  background: #f00 !important;
  color: #000 !important;
  transform: scale(1.08);
  box-shadow: 0 0 18px rgba(255,0,0,.6);
}
.arrow {
  position: absolute;
  font-size: 48px;
  opacity: 0.9;
  pointer-events: none;
  transform: translate(-50%, -50%);
}
.arrow.hit { opacity: 0.4; }
.arrow.miss { opacity: 0.4; filter: brightness(0.5); }
.bottom {
  position: absolute;
  bottom: 60px;
  text-align: center;
}
.hpbar {
  width: 60%;
  height: 14px;
  background: #333;
  border-radius: 7px;
  overflow: hidden;
  margin: 6px auto;
}
.hpfill {
  height: 100%;
  background: #0f0;
  width: 100%;
  transition: width 0.15s;
}
#center {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%,-50%);
  text-align: center;
}
#botTurn {
  display: none;
  color: #0ff;
  font-size: 22px;
}
#overlay {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.7);
  display: none;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}
#overlay h1 {
  font-size: 56px;
  color: #fff;
}
#overlay button {
  background: #0f0;
  border: none;
  color: #000;
  font-size: 22px;
  padding: 10px 26px;
  border-radius: 8px;
  cursor: pointer;
}
</style>
</head>
<body>

<div class="game">
  <div class="side" id="playerSide">
    <div class="top">
      <div class="static left">A</div>
      <div class="static down">S</div>
      <div class="static up">W</div>
      <div class="static right">D</div>
    </div>
    <div class="bottom">
      <div class="hpbar"><div class="hpfill" id="playerFill"></div></div>
      <h2>YOU</h2>
    </div>
  </div>

  <div class="side" id="ubbaSide">
    <div class="top">
      <div class="static left">←</div>
      <div class="static down">↓</div>
      <div class="static up">↑</div>
      <div class="static right">→</div>
    </div>
    <div class="bottom">
      <div class="hpbar"><div class="hpfill" id="ubbaFill"></div></div>
      <h2>UBBA</h2>
    </div>
  </div>
</div>

<div id="center">
  <div id="score">SCORE: 0</div>
  <div id="combo"></div>
  <div id="level">LEVEL 1</div>
  <div id="botTurn">UBBA’S TURN</div>
</div>

<div id="overlay">
  <h1 id="resultText"></h1>
  <button id="restartBtn">PLAY AGAIN</button>
</div>

<script>
const CONFIG = {
  baseSpeed: 3.2,
  spawnGap: 600,
  hitTolerance: 56,
  hpGain: 0.2,
  hpLoss: 1,
  rounds: 3,
  maxHP: 12
};

const state = {
  playing:false, round:1, score:0, combo:0, maxCombo:0,
  playerHP:CONFIG.maxHP, ubbaHP:CONFIG.maxHP, arrows:[], sequence:[], isBotPhase:true
};

const els = {
  playerSide:document.getElementById('playerSide'),
  ubbaSide:document.getElementById('ubbaSide'),
  score:document.getElementById('score'),
  combo:document.getElementById('combo'),
  level:document.getElementById('level'),
  botTurn:document.getElementById('botTurn'),
  playerFill:document.getElementById('playerFill'),
  ubbaFill:document.getElementById('ubbaFill'),
  overlay:document.getElementById('overlay'),
  resultText:document.getElementById('resultText'),
  restartBtn:document.getElementById('restartBtn')
};

const KEY_MAP = {
  a:'left', s:'down', w:'up', d:'right',
  arrowleft:'left', arrowdown:'down', arrowup:'up', arrowright:'right'
};

document.addEventListener('keydown',e=>{
  const k=e.key.toLowerCase();
  if(KEY_MAP[k] && state.playing && !state.isBotPhase) playerPress(k);
});

function flashStatic(side,type,color='green'){
  const el=(side==='player'?els.playerSide:els.ubbaSide).querySelector('.static.'+type);
  if(!el)return;
  const cls=color==='red'?'fail':'active';
  el.classList.add(cls);
  setTimeout(()=>el.classList.remove(cls),150);
}

function spawnArrow(type,side){
  const arrow=document.createElement('div');
  arrow.className='arrow';
  arrow.textContent={left:'←',down:'↓',up:'↑',right:'→'}[type];
  arrow.style.color=(side==='player')?'#0f0':'#0ff';
  arrow.dataset.type=type;
  arrow.dataset.side=side;
  (side==='player'?els.playerSide:els.ubbaSide).appendChild(arrow);
  const targets=(side==='player'?els.playerSide:els.ubbaSide).querySelectorAll('.static');
  const target=[...targets].find(t=>t.classList.contains(type));
  const rect=target.getBoundingClientRect();
  const base=target.parentElement.getBoundingClientRect();
  arrow.style.left=(rect.left-base.left+rect.width/2)+'px';
  arrow.style.bottom='0px';
  state.arrows.push({el:arrow,type,side,y:0,hit:false});
}

function makeSequence(round){
  const base=['left','down','up','right'];
  let seq=[];
  if(round<3){
    const len=6+(round-1)*4;
    for(let i=0;i<len;i++)seq.push(base[Math.floor(Math.random()*base.length)]);
  }else{
    const combos=[['up','right'],['left','up'],['down','right'],['left','down','up']];
    const len=22;
    for(let i=0;i<len;i++){
      if(Math.random()<0.25)seq.push(combos[Math.floor(Math.random()*combos.length)]);
      else seq.push(base[Math.floor(Math.random()*base.length)]);
    }
  }
  return seq;
}

function playRound(roundNum){
  state.sequence=makeSequence(roundNum);
  state.isBotPhase=true;
  els.botTurn.style.display='block';
  state.arrows.forEach(a=>a.el.remove());
  state.arrows=[];
  const spd=roundNum===3?CONFIG.baseSpeed*2:CONFIG.baseSpeed;
  let idx=0;
  const spawnInt=setInterval(()=>{
    if(idx>=state.sequence.length){
      clearInterval(spawnInt);
      setTimeout(()=>{state.isBotPhase=false;els.botTurn.style.display='none';spawnPlayerSequence(state.sequence,spd);},600);
      return;
    }
    const step=state.sequence[idx];
    if(Array.isArray(step))step.forEach(t=>spawnArrow(t,'ubba'));
    else spawnArrow(step,'ubba');
    idx++;
  },roundNum===3?350:600);
}

function spawnPlayerSequence(seq,spd){
  let i=0;
  const t=setInterval(()=>{
    if(i>=seq.length){clearInterval(t);return;}
    const step=seq[i];
    if(Array.isArray(step))step.forEach(t=>spawnArrow(t,'player'));
    else spawnArrow(step,'player');
    i++;
  },CONFIG.spawnGap);
  state.playing=true;
  loop();
}

function loop(){
  if(!state.playing)return;
  for(let i=state.arrows.length-1;i>=0;i--){
    const a=state.arrows[i];
    if(a.hit){state.arrows.splice(i,1);continue;}
    a.y+=state.round===3?CONFIG.baseSpeed*2:CONFIG.baseSpeed;
    a.el.style.bottom=a.y+'px';
    const rect=a.el.getBoundingClientRect();
    if(rect.top<0){
      if(a.side==='player'&&!a.hit){
        a.hit=true;
        flashStatic('player',a.type,'red');
        state.playerHP=Math.max(0,state.playerHP-CONFIG.hpLoss);
        state.combo=0;
        updateHUD();
      }
      a.el.remove();
      state.arrows.splice(i,1);
    }
  }
  checkRoundCompletion();
  requestAnimationFrame(loop);
}

function computeTargets(){
  return{
    player:{
      left:els.playerSide.querySelector('.static.left').getBoundingClientRect(),
      down:els.playerSide.querySelector('.static.down').getBoundingClientRect(),
      up:els.playerSide.querySelector('.static.up').getBoundingClientRect(),
      right:els.playerSide.querySelector('.static.right').getBoundingClientRect()
    }
  };
}

function playerPress(key){
  const type=KEY_MAP[key];
  const targets=computeTargets().player;
  const match=state.arrows.filter(a=>a.side==='player'&&!a.hit&&a.type===type);
  if(match.length===0){flashStatic('player',type,'red');failPenalty();return;}
  let hit=false;
  for(const a of match){
    const r=a.el.getBoundingClientRect();
    const cy=r.top+r.height/2;
    const scy=(targets[a.type].top+targets[a.type].height/2);
    if(Math.abs(cy-scy)<=CONFIG.hitTolerance){
      hit=true;
      a.hit=true;
      a.el.remove();
      state.score+=100;
      state.combo++;
      state.maxCombo=Math.max(state.combo,state.maxCombo);
      state.playerHP=Math.min(CONFIG.maxHP,state.playerHP+CONFIG.hpGain);
      state.ubbaHP=Math.max(0,state.ubbaHP-CONFIG.hpLoss);
      updateHUD();
      break;
    }
  }
  if(!hit){flashStatic('player',type,'red');failPenalty();}
  checkRoundCompletion();
}

function failPenalty(){
  state.playerHP=Math.max(0,state.playerHP-CONFIG.hpLoss);
  state.combo=0;
  updateHUD();
}

function checkRoundCompletion(){
  const remaining=state.arrows.filter(a=>a.side==='player').length;
  if(remaining===0&&!state.isBotPhase){
    state.playing=false;
    if(state.round<CONFIG.rounds){state.round++;setTimeout(()=>playRound(state.round),1000);}
    else endGame();
  }
}

function updateHUD(){
  const maxHP=CONFIG.maxHP;
  els.score.textContent=`SCORE: ${state.score}`;
  els.combo.style.display=state.combo>1?'block':'none';
  els.combo.textContent=`COMBO: ${state.combo}`;
  els.level.textContent=`LEVEL ${state.round}`;
  els.playerFill.style.width=`${(state.playerHP/maxHP)*100}%`;
  els.ubbaFill.style.width=`${(state.ubbaHP/maxHP)*100}%`;
}

function endGame(){
  els.overlay.style.display='flex';
  els.resultText.textContent=(state.playerHP>state.ubbaHP)?'YOU WIN!':'YOU LOSE!';
}

els.restartBtn.onclick=()=>location.reload();
playRound(1);
</script>
</body>
</html>
