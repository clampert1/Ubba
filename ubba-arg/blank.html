<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UBBA DANCE BATTLE — Fixed</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:#000;color:#fff;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
  #game{position:relative;width:100vw;height:100vh}
  #background{position:absolute;inset:0;background:url('https://raw.githubusercontent.com/clampert1/Ubba/main/ubba-arg/assets/cameras/office.png') center/cover no-repeat;filter:brightness(.35)}
  /* health */
  #hud{position:absolute;top:16px;left:50%;transform:translateX(-50%);width:88%;display:flex;justify-content:space-between;align-items:center;z-index:50}
  .health{width:380px;height:34px;background:#222;border:3px solid #fff;border-radius:6px;position:relative;overflow:hidden}
  .health .fill{position:absolute;left:0;top:0;height:100%;background:#0f0;width:100%;transition:width .25s}
  #ubba .fill{background:#f33;left:auto;right:0}
  .label{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-weight:700;text-shadow:1px 1px 3px #000}
  /* top controls */
  #top-controls{position:absolute;top:70px;left:50%;transform:translateX(-50%);width:100%;max-width:1340px;display:flex;justify-content:space-between;align-items:flex-start;gap:40px;z-index:60;padding:0 30px}
  .lane-side{display:flex;gap:18px;align-items:flex-start}
  .arrow-target{width:86px;height:86px;background:rgba(0,0,0,.55);border-radius:10px;border:4px solid #222;display:flex;align-items:center;justify-content:center;position:relative}
  .static{position:absolute;bottom:6px;left:50%;transform:translateX(-50%);width:70px;height:70px;border-radius:8px;background:#222;color:#fff;font-weight:700;display:flex;align-items:center;justify-content:center;font-size:22px;border:3px solid}
  .static.left{border-color:#4ecdc4}
  .static.down{border-color:#ffe66d;color:#000}
  .static.up{border-color:#ff6b6b}
  .static.right{border-color:#ff9f1c}
  .static.active{background:#0f0;color:#000;transform:translateX(-50%) scale(1.06);box-shadow:0 0 18px rgba(0,255,0,.6)}
  /* characters + spawn baseline */
  #characters{position:absolute;left:50%;transform:translateX(-50%);bottom:48px;display:flex;justify-content:space-between;width:95%;max-width:1340px;z-index:50;padding:0 30px}
  .char{width:210px;height:210px;border-radius:10px;border:4px solid #fff;display:flex;align-items:center;justify-content:center;background:#224a84;font-size:22px}
  #ubbaChar{background:#000 url('https://raw.githubusercontent.com/clampert1/Ubba/main/ubba-arg/assets/sprites/ubba.png') center/contain no-repeat}
  /* falling arrows container */
  #arrows{position:absolute;inset:0;pointer-events:none;z-index:40}
  .arrow{position:absolute;width:70px;height:70px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:22px;color:#fff;border:3px solid}
  .arrow.left{background:#4ecdc4;border-color:#4ecdc4}
  .arrow.down{background:#ffe66d;border-color:#ffe66d;color:#000}
  .arrow.up{background:#ff6b6b;border-color:#ff6b6b}
  .arrow.right{background:#ff9f1c;border-color:#ff9f1c}
  /* HUD text */
  #score{position:absolute;top:112px;left:50%;transform:translateX(-50%);font-size:22px;color:#dfe;text-shadow:1px 1px 3px #000;z-index:60}
  #level{position:absolute;top:150px;left:50%;transform:translateX(-50%);font-size:20px;color:#fff;z-index:60}
  #combo{position:absolute;top:176px;left:50%;transform:translateX(-50%);font-size:18px;color:#8ff;display:none;z-index:60}
  #botTurn{position:absolute;top:200px;left:50%;transform:translateX(-50%);font-size:28px;color:#ffd700;display:none;z-index:60}
  /* start/results */
  #start,#results{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background:rgba(0,0,0,.8);z-index:120}
  #results{display:none}
  .btn{background:linear-gradient(135deg,#ff6b6b,#ff8e8e);color:#fff;padding:14px 28px;border-radius:10px;border:3px solid #fff;cursor:pointer;font-size:18px}
  /* effects */
  .hit,.miss{position:absolute;width:80px;height:80px;border-radius:50%;pointer-events:none;z-index:130;animation:eff .35s forwards}
  .hit{background:rgba(0,255,0,.4)}
  .miss{background:rgba(255,0,0,.4)}
  @keyframes eff{from{transform:scale(.5);opacity:1}to{transform:scale(2);opacity:0}}
  /* responsive safety */
  @media(max-width:900px){.lane-side{gap:10px}.arrow-target{width:70px;height:70px}.static{width:56px;height:56px;font-size:18px}}
</style>
</head>
<body>
<div id="game">
  <div id="background"></div>

  <div id="hud">
    <div class="health" id="player"><div class="fill" style="width:100%"></div><div class="label">PLAYER</div></div>
    <div class="health" id="ubba"><div class="fill" style="width:100%"></div><div class="label">UBBA</div></div>
  </div>

  <!-- Top controls: LEFT = player, RIGHT = ubba (keeps wide margin like original) -->
  <div id="top-controls">
    <div class="lane-side" id="player-side">
      <div class="arrow-target"><div class="static left" data-key="a">A</div></div>
      <div class="arrow-target"><div class="static down" data-key="s">S</div></div>
      <div class="arrow-target"><div class="static up" data-key="w">W</div></div>
      <div class="arrow-target"><div class="static right" data-key="d">D</div></div>
    </div>

    <div class="lane-side" id="ubba-side">
      <div class="arrow-target"><div class="static left" data-key="left">←</div></div>
      <div class="arrow-target"><div class="static down" data-key="down">↓</div></div>
      <div class="arrow-target"><div class="static up" data-key="up">↑</div></div>
      <div class="arrow-target"><div class="static right" data-key="right">→</div></div>
    </div>
  </div>

  <div id="score">SCORE: 0</div>
  <div id="combo">COMBO: 0</div>
  <div id="level">LEVEL 1</div>
  <div id="botTurn">UBBA'S TURN</div>

  <!-- characters (centered horizontally, far apart like original) -->
  <div id="characters">
    <div class="char" id="you">YOU</div>
    <div class="char" id="ubbaChar"></div>
  </div>

  <div id="arrows"></div>

  <!-- overlays -->
  <div id="start">
    <h1 style="margin-bottom:10px;color:#ff6b6b">UBBA DANCE BATTLE</h1>
    <p style="margin-bottom:14px">Watch Ubba, then replicate his sequence — keys: A S W D</p>
    <button class="btn" id="startBtn">START BATTLE</button>
  </div>

  <div id="results">
    <h1 id="resultTitle" style="margin-bottom:8px">BATTLE COMPLETE</h1>
    <div id="resultText" style="margin-bottom:16px"></div>
    <button class="btn" id="replay">PLAY AGAIN</button>
  </div>
</div>

<script>
/* Minimal comments — crucial lines only. */

/* CONFIG */
const CONFIG = {
  speed: 3.2,            // px per frame
  spawnGap: 600,         // ms between arrows in sequence
  hitTolerance: 56,      // px center distance tolerance
  hpGain: 2,
  hpLoss: 1,
  rounds: 3
};

/* GAME STATE */
const state = {
  playing: false,
  round: 1,
  score: 0,
  combo: 0,
  maxCombo: 0,
  playerHP: 100,
  ubbaHP: 100,
  arrows: [],            // active moving arrows
  sequence: [],          // current round sequence (array of types)
  isBotPhase: true,
  ubbaTimers: []         // scheduled ubba auto-hit timers
};

/* references */
const els = {
  start: document.getElementById('start'),
  startBtn: document.getElementById('startBtn'),
  results: document.getElementById('results'),
  resultTitle: document.getElementById('resultTitle'),
  resultText: document.getElementById('resultText'),
  replay: document.getElementById('replay'),
  score: document.getElementById('score'),
  combo: document.getElementById('combo'),
  level: document.getElementById('level'),
  botTurn: document.getElementById('botTurn'),
  arrows: document.getElementById('arrows'),
  pHP: document.querySelector('#player .fill'),
  uHP: document.querySelector('#ubba .fill'),
  playerSide: document.getElementById('player-side'),
  ubbaSide: document.getElementById('ubba-side')
};

/* helpers */
const KEY_MAP = { a: 'left', s: 'down', w: 'up', d: 'right' };
const ARROW_SYMBOL = { left: '←', down: '↓', up: '↑', right: '→' };

/* compute exact center X of each static target (both sides) and return mapping */
function computeTargetPositions() {
  const mapping = { player: {}, ubba: {} };
  const playerStatics = els.playerSide.querySelectorAll('.static');
  const ubbaStatics = els.ubbaSide.querySelectorAll('.static');
  playerStatics.forEach(s => mapping.player[s.classList.contains('left') ? 'left' : s.classList.contains('down') ? 'down' : s.classList.contains('up') ? 'up' : 'right'] = s.getBoundingClientRect());
  ubbaStatics.forEach(s => mapping.ubba[s.classList.contains('left') ? 'left' : s.classList.contains('down') ? 'down' : s.classList.contains('up') ? 'up' : 'right'] = s.getBoundingClientRect());
  return mapping;
}

/* create a sequence for the round (longer each round) */
function makeSequence(round) {
  const types = ['left','down','up','right'];
  const len = 6 + (round - 1) * 4;
  const seq = [];
  for (let i=0;i<len;i++) seq.push(types[Math.floor(Math.random()*types.length)]);
  return seq;
}

/* spawn moving arrow — uses target rect to perfectly align X; spawnY is above characters */
function spawnArrow(type, side) {
  const targetRects = computeTargetPositions();
  const staticRect = side === 'player' ? targetRects.player[type] : targetRects.ubba[type];
  if (!staticRect) return null;

  const arrow = document.createElement('div');
  arrow.className = `arrow ${type}`;
  arrow.textContent = ARROW_SYMBOL[type];

  // set exact left so arrow center matches static center
  const left = Math.round(staticRect.left + staticRect.width/2 - 35); // arrow width 70 -> half =35
  arrow.style.left = left + 'px';

  // spawn bottom just above characters: characters top -> bottom dist
  const charsRect = document.getElementById('characters').getBoundingClientRect();
  const spawnBottom = Math.max(20, window.innerHeight - charsRect.top + 12); // slight offset
  arrow.style.bottom = spawnBottom + 'px';

  document.getElementById('arrows').appendChild(arrow);

  const obj = {
    el: arrow,
    type,
    side,
    y: spawnBottom, // bottom in px
    hit: false
  };
  state.arrows.push(obj);

  // If ubba's arrow, schedule ubba auto-hit for perfect timing
  if (side === 'ubba') scheduleUbbaAutoHit(obj, staticRect);

  return obj;
}

/* Ubba auto-hit scheduler: compute frames/time until arrow center matches static center, then simulate perfect hit */
function scheduleUbbaAutoHit(arrowObj, staticRect) {
  // compute current center Y positions
  const arrowRect = arrowObj.el.getBoundingClientRect();
  const arrowCenterY = arrowRect.top + arrowRect.height / 2;
  const staticCenterY = staticRect.top + staticRect.height / 2;
  const distance = arrowCenterY - staticCenterY; // positive if arrow below static (it will move up decreasing this)

  // time = distance / (speed * fps). approximate fps 60 => px per ms = speed / 16.66
  const pxPerMs = CONFIG.speed / (1000/60);
  const timeMs = Math.max(0, distance / pxPerMs);

  // schedule a timer a bit earlier to flash the static key, then remove arrow at perfect time
  const flashAdvance = 70; // ms to flash slightly before actual hit
  const flashTimer = setTimeout(()=> {
    flashStatic('ubba', arrowObj.type, 140);
  }, Math.max(0, timeMs - flashAdvance));
  const hitTimer = setTimeout(()=> {
    // if arrow still exists and not hit, register as ubba's successful hit (no hp changes to ubba, but visual + remove)
    if (!arrowObj.hit) {
      arrowObj.hit = true;
      // remove element if still in DOM
      if (arrowObj.el && arrowObj.el.parentElement) arrowObj.el.remove();
      // remove from state.arrows
      state.arrows = state.arrows.filter(a=>a!==arrowObj);
    }
  }, Math.max(0, timeMs + 12));
  state.ubbaTimers.push(flashTimer, hitTimer);
}

/* flash static key on side ('player' or 'ubba') for ms duration */
function flashStatic(side, type, ms=140) {
  const container = side==='player' ? els.playerSide : els.ubbaSide;
  const staticEl = Array.from(container.querySelectorAll('.static')).find(s => {
    return s.classList.contains(type);
  });
  if (!staticEl) return;
  staticEl.classList.add('active');
  setTimeout(()=>staticEl.classList.remove('active'), ms);
}

/* main game loop — moves arrows upward and checks for arrows that passed top (off screen) */
function loop() {
  if (!state.playing) return;
  // move arrows
  for (let i = state.arrows.length - 1; i >= 0; i--) {
    const a = state.arrows[i];
    if (a.hit) { // skip
      state.arrows.splice(i,1);
      continue;
    }
    a.y += CONFIG.speed;
    a.el.style.bottom = a.y + 'px';
    // if arrow passed top of viewport (rare), remove
    const rect = a.el.getBoundingClientRect();
    if (rect.bottom < 0) {
      // if a player's arrow passed the hit zone without being hit, it's a miss
      if (a.side === 'player' && !a.hit) {
        // penalize
        state.playerHP = Math.max(0, state.playerHP - CONFIG.hpLoss);
        state.combo = 0;
        showEffect(a.el, 'miss');
        updateHUD();
      }
      a.el.remove();
      state.arrows.splice(i,1);
    }
  }
  requestAnimationFrame(loop);
}

/* player attempts to hit a key */
function playerPress(key) {
  if (!state.playing || state.isBotPhase) return;
  const type = KEY_MAP[key];
  if (!type) return;

  flashStatic('player', type, 160);

  // find a player-side arrow of that type within hit tolerance
  const staticRect = computeTargetPositions().player[type];
  let hitAny = false;
  for (let i = 0; i < state.arrows.length; i++) {
    const a = state.arrows[i];
    if (a.side !== 'player' || a.type !== type || a.hit) continue;
    const arrowRect = a.el.getBoundingClientRect();
    const arrowCenterY = arrowRect.top + arrowRect.height / 2;
    const staticCenterY = staticRect.top + staticRect.height / 2;
    const dist = Math.abs(arrowCenterY - staticCenterY);
    if (dist <= CONFIG.hitTolerance) {
      // success
      a.hit = true;
      hitAny = true;

      // visual & scoring
      showEffect(a.el, 'hit');
      // remove arrow element
      if (a.el && a.el.parentElement) a.el.remove();
      state.arrows.splice(i,1);

      state.score += 100;
      state.combo += 1;
      state.maxCombo = Math.max(state.maxCombo, state.combo);
      state.playerHP = Math.min(100, state.playerHP + CONFIG.hpGain);
      // ubba loses hp on player hit
      state.ubbaHP = Math.max(0, state.ubbaHP - CONFIG.hpLoss);

      updateHUD();
      break;
    }
  }

  if (!hitAny) {
    // no valid hit -> penalty (anti-spam)
    state.playerHP = Math.max(0, state.playerHP - CONFIG.hpLoss);
    state.combo = 0;
    updateHUD();
  }

  // check for end of round early: if no player arrows remain and ubba phase is over and sequence consumed
  checkRoundCompletion();
}

/* visual effect near arrow center */
function showEffect(el, cls) {
  try {
    const r = el.getBoundingClientRect();
    const e = document.createElement('div');
    e.className = cls === 'hit' ? 'hit' : 'miss';
    e.style.left = (r.left + r.width/2 - 40) + 'px';
    e.style.top = (r.top + r.height/2 - 40) + 'px';
    document.body.appendChild(e);
    setTimeout(()=>e.remove(), 360);
  } catch(e){}
}

/* UI updates */
function updateHUD() {
  els.score.textContent = `SCORE: ${state.score}`;
  els.pHP.style.width = `${state.playerHP}%`;
  els.uHP.style.width = `${state.ubbaHP}%`;
  if (state.combo > 1) {
    els.combo.style.display = 'block';
    els.combo.textContent = `COMBO: ${state.combo}`;
  } else {
    els.combo.style.display = 'none';
  }
  els.level.textContent = `LEVEL ${state.round}`;
}

/* play full round: ubba shows (botPhase) then player arrows spawn to match */
function playRound(roundNum) {
  state.sequence = makeSequence(roundNum);
  state.isBotPhase = true;
  els.botTurn.style.display = 'block';

  // clear any leftover arrows/timers
  cleanupRoundPrep();

  // play ubba's demonstration: spawn ubba arrows spaced by spawnGap
  let idx = 0;
  const spawnInterval = setInterval(() => {
    if (idx >= state.sequence.length) {
      clearInterval(spawnInterval);
      // after Ubba done, let player play after a short wait
      setTimeout(() => {
        state.isBotPhase = false;
        els.botTurn.style.display = 'none';
        // spawn player's matching arrows (they will move up, player must hit)
        spawnPlayerSequence(state.sequence);
      }, 600);
      return;
    }
    spawnArrow(state.sequence[idx], 'ubba');
    idx++;
  }, CONFIG.spawnGap);
}

/* spawn player's matching arrow sequence (same spacing) */
function spawnPlayerSequence(seq) {
  let i = 0;
  const t = setInterval(() => {
    if (i >= seq.length) { clearInterval(t); return; }
    spawnArrow(seq[i], 'player');
    i++;
  }, CONFIG.spawnGap);
}

/* check if round complete: when there are no remaining arrows for player and no scheduled ubba timers */
function checkRoundCompletion() {
  // if player phase and no player arrows remain (all either hit or passed), finish
  const playerArrowsExist = state.arrows.some(a => a.side === 'player');
  if (!state.isBotPhase && !playerArrowsExist) {
    // round finished
    state.round++;
    if (state.round > CONFIG.rounds || state.playerHP <= 0 || state.ubbaHP <= 0) {
      finishGame();
    } else {
      // small delay then next round
      setTimeout(()=> {
        updateHUD();
        playRound(state.round);
      }, 900);
    }
  }
}

/* cleanup timers and arrows when starting a round */
function cleanupRoundPrep() {
  // clear scheduled ubba timers
  state.ubbaTimers.forEach(t => clearTimeout(t));
  state.ubbaTimers.length = 0;
  // remove active arrows from DOM and state
  state.arrows.forEach(a => { try { a.el.remove(); } catch(e){} });
  state.arrows.length = 0;
}

/* endgame */
function finishGame() {
  state.playing = false;
  cleanupRoundPrep();
  els.results.style.display = 'flex';
  els.start.style.display = 'none';
  const victory = state.ubbaHP <= 0 && state.playerHP > 0 || state.score >= 600; // fallback score check
  els.resultTitle.textContent = victory ? 'VICTORY!' : 'DEFEAT!';
  els.resultTitle.style.color = victory ? '#1df53a' : '#ff4b4b';
  els.resultText.innerHTML = `SCORE: ${state.score} &nbsp;&bull;&nbsp; MAX COMBO: ${state.maxCombo}`;
}

/* keyboard input: player keys */
document.addEventListener('keydown', (e) => {
  if (!state.playing) return;
  const k = e.key.toLowerCase();
  if (k in KEY_MAP) {
    // prevent holding down auto-repeat from spamming: we will allow repeated presses but they will be penalized if no arrow
    playerPress(k);
  }
});

/* UI buttons */
els.startBtn.addEventListener('click', ()=> {
  els.start.style.display = 'none';
  els.results.style.display = 'none';
  startGame();
});
els.replay.addEventListener('click', ()=> location.reload());

/* start game */
function startGame() {
  state.playing = true;
  state.round = 1;
  state.score = 0;
  state.combo = 0;
  state.maxCombo = 0;
  state.playerHP = 100;
  state.ubbaHP = 100;
  updateHUD();
  playRound(state.round);
  requestAnimationFrame(loop);
}

/* handle window resize (recompute positions implicitly when spawn) */
window.addEventListener('resize', ()=>{ /* nothing — positions recomputed at spawn time */ });

/* DONE: initial UI show */
updateHUD();

</script>
</body>
</html>
