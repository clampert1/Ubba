<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UBBA DANCE BATTLE — Expert</title>
<style>
/* --- same layout as before (shortened for brevity) --- */
body{margin:0;background:#000;color:#fff;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
.arrow-target{width:86px;height:86px;background:rgba(0,0,0,.55);border-radius:10px;border:4px solid #222;display:flex;align-items:center;justify-content:center;position:relative}
.static{position:absolute;bottom:6px;left:50%;transform:translateX(-50%);width:70px;height:70px;border-radius:8px;background:#222;color:#fff;font-weight:700;display:flex;align-items:center;justify-content:center;font-size:22px;border:3px solid}
.static.left{border-color:#4ecdc4}
.static.down{border-color:#ffe66d}
.static.up{border-color:#ff6b6b}
.static.right{border-color:#ff9f1c}
.static.active{background:#0f0;color:#000;transform:translateX(-50%) scale(1.06);box-shadow:0 0 18px rgba(0,255,0,.6)}
/* everything else identical to previous version */
</style>
</head>
<body>
<!-- use identical body structure from previous working version -->
<!-- (omitted here for brevity; only script below changed) -->

<script>
const CONFIG = {
  baseSpeed: 3.2,
  spawnGap: 600,
  hitTolerance: 56,
  hpGain: 2,
  hpLoss: 1,
  rounds: 3
};

const state = {
  playing:false, round:1, score:0, combo:0, maxCombo:0,
  playerHP:100, ubbaHP:100, arrows:[], sequence:[], isBotPhase:true, ubbaTimers:[]
};

/* previous helper & DOM refs unchanged (reuse from your working version) */

/* --- Modified makeSequence --- */
function makeSequence(round){
  const base = ['left','down','up','right'];
  let seq=[];
  if(round<3){
    const len = 6 + (round-1)*4;
    for(let i=0;i<len;i++) seq.push(base[Math.floor(Math.random()*base.length)]);
  } else {
    // Expert mode: 20–24 steps, including chords
    const combos=[['up','right'],['left','up'],['down','right'],['left','down','up']];
    const len=22;
    for(let i=0;i<len;i++){
      if(Math.random()<0.25) seq.push(combos[Math.floor(Math.random()*combos.length)]);
      else seq.push(base[Math.floor(Math.random()*base.length)]);
    }
  }
  return seq;
}

/* --- Modified playRound to scale speed --- */
function playRound(roundNum){
  state.sequence=makeSequence(roundNum);
  state.isBotPhase=true;
  els.botTurn.style.display='block';
  cleanupRoundPrep();
  // speed scaling
  CONFIG.speed = CONFIG.baseSpeed * (roundNum===3?2.0:1);
  CONFIG.spawnGap = roundNum===3?350:600;
  // ubba show
  let idx=0;
  const spawnInterval=setInterval(()=>{
    if(idx>=state.sequence.length){
      clearInterval(spawnInterval);
      setTimeout(()=>{
        state.isBotPhase=false;
        els.botTurn.style.display='none';
        spawnPlayerSequence(state.sequence);
      },600);
      return;
    }
    const step=state.sequence[idx];
    if(Array.isArray(step)) step.forEach(t=>spawnArrow(t,'ubba'));
    else spawnArrow(step,'ubba');
    idx++;
  },CONFIG.spawnGap);
}

/* --- Modified spawnPlayerSequence to support chords --- */
function spawnPlayerSequence(seq){
  let i=0;
  const t=setInterval(()=>{
    if(i>=seq.length){clearInterval(t);return;}
    const step=seq[i];
    if(Array.isArray(step)) step.forEach(t=>spawnArrow(t,'player'));
    else spawnArrow(step,'player');
    i++;
  },CONFIG.spawnGap);
}

/* --- Add chord detection --- */
const chordWindow=200;
const recentKeys=[];
document.addEventListener('keydown',e=>{
  if(!state.playing||state.isBotPhase)return;
  const k=e.key.toLowerCase();
  if(!(k in KEY_MAP))return;
  const now=performance.now();
  recentKeys.push({key:k,time:now});
  // clean old
  while(recentKeys.length&&now-recentKeys[0].time>chordWindow)recentKeys.shift();
  playerPress(k);
});

/* --- playerPress extended for chords --- */
function playerPress(key){
  const type=KEY_MAP[key];
  flashStatic('player',type,160);
  const targetPos=computeTargetPositions().player[type];
  let hitAny=false;
  // gather arrows by type
  const matching=state.arrows.filter(a=>a.side==='player'&&!a.hit);
  // find chord patterns nearby: check if multiple arrows overlap vertically within tolerance
  const groupHits=matching.filter(a=>{
    const r=a.el.getBoundingClientRect();
    const cy=r.top+r.height/2;
    const scy=targetPos.top+targetPos.height/2;
    return Math.abs(cy-scy)<=CONFIG.hitTolerance;
  });

  // determine if a chord arrow group (same Y band) exists
  if(groupHits.length>1){
    // if all their types are contained in recent pressed keys set within window, success
    const pressedSet=new Set(recentKeys.map(k=>KEY_MAP[k.key]));
    const needTypes=new Set(groupHits.map(a=>a.type));
    const allPressed=[...needTypes].every(t=>pressedSet.has(t));
    if(allPressed){
      hitAny=true;
      groupHits.forEach(a=>{
        a.hit=true;
        showEffect(a.el,'hit');
        a.el.remove();
      });
      state.arrows=state.arrows.filter(a=>!a.hit);
    }
  }else{
    // normal single arrow check
    for(let i=0;i<state.arrows.length;i++){
      const a=state.arrows[i];
      if(a.side!=='player'||a.type!==type||a.hit)continue;
      const r=a.el.getBoundingClientRect();
      const cy=r.top+r.height/2;
      const scy=targetPos.top+targetPos.height/2;
      if(Math.abs(cy-scy)<=CONFIG.hitTolerance){
        hitAny=true;
        a.hit=true;
        showEffect(a.el,'hit');
        a.el.remove();
        state.arrows.splice(i,1);
        break;
      }
    }
  }

  if(hitAny){
    state.score+=100;
    state.combo++;
    state.maxCombo=Math.max(state.combo,state.maxCombo);
    state.playerHP=Math.min(100,state.playerHP+CONFIG.hpGain);
    state.ubbaHP=Math.max(0,state.ubbaHP-CONFIG.hpLoss);
  }else{
    state.playerHP=Math.max(0,state.playerHP-CONFIG.hpLoss);
    state.combo=0;
  }
  updateHUD();
  checkRoundCompletion();
}

/* all other functions (loop, flashStatic, scheduleUbbaAutoHit, etc.) remain identical */
</script>
</body>
</html>
