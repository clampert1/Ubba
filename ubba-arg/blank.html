<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Ubba Dance Battle — Fixed Final</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:#000;color:#fff;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
  /* background */
  #bg{position:fixed;inset:0;background:url('https://raw.githubusercontent.com/clampert1/Ubba/main/ubba-arg/assets/cameras/office.png') center/cover no-repeat;filter:brightness(.32);z-index:0}
  /* top HUD */
  #topHUD{position:relative;z-index:60;padding:18px 32px;display:flex;justify-content:space-between;align-items:center}
  .health{width:380px;height:34px;background:#222;border:3px solid #fff;border-radius:6px;overflow:hidden;position:relative}
  .fill{position:absolute;top:0;left:0;height:100%;background:#0f0;width:100%;transition:width .18s}
  #ubbaFill{background:#ff3b3b;left:auto;right:0}
  .label{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-weight:700;text-shadow:1px 1px 3px #000}
  /* top controls (wide center) */
  #controls{position:relative;z-index:70;display:flex;justify-content:space-between;align-items:flex-start;width:100%;max-width:1320px;margin:0 auto;padding:8px 24px}
  .lane{display:flex;gap:18px;align-items:flex-start}
  .targetWrap{width:86px;height:86px;background:transparent;display:flex;align-items:center;justify-content:center}
  .static{position:relative;width:70px;height:70px;border-radius:8px;background:#222;color:#fff;display:flex;align-items:center;justify-content:center;font-size:22px;border:3px solid}
  .static.left{border-color:#4ecdc4}
  .static.down{border-color:#ffe66d}
  .static.up{border-color:#ff6b6b}
  .static.right{border-color:#ff9f1c}
  .static.active{background:#0f0;color:#000;transform:scale(1.06);box-shadow:0 0 18px rgba(0,255,0,.6)}
  .static.fail{background:#f00;color:#000;transform:scale(1.06);box-shadow:0 0 18px rgba(255,0,0,.6)}
  /* center UI text */
  #centerUI{position:absolute;left:50%;top:38%;transform:translate(-50%,-50%);text-align:center;z-index:65;pointer-events:none}
  #score{font-size:18px;color:#dfe}
  #level{margin-top:6px;font-size:16px}
  #combo{margin-top:6px;font-size:15px;color:#8ff;display:none}
  #botTurn{margin-top:8px;font-size:20px;color:#ffd700;display:none}
  /* characters bottom area */
  #characters{position:relative;z-index:50;display:flex;justify-content:space-between;align-items:flex-end;width:100%;max-width:1320px;margin:0 auto;bottom:44px;position:fixed;left:0;right:0;padding:0 24px}
  .char{width:200px;height:200px;border-radius:10px;border:4px solid #fff;display:flex;align-items:center;justify-content:center;font-size:22px;background:linear-gradient(135deg,#1e3c72,#2a5298)}
  #ubbaChar{background:#000 url('https://raw.githubusercontent.com/clampert1/Ubba/main/ubba-arg/assets/sprites/ubba.png') center/contain no-repeat}
  .hpRow{width:100%;display:flex;justify-content:center;margin-top:8px}
  .hpbar{width:60%;height:12px;background:#333;border-radius:8px;overflow:hidden}
  /* arrows overlay */
  #arrows{position:fixed;inset:0;pointer-events:none;z-index:55}
  .arrow{position:absolute;width:70px;height:70px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:22px;color:#fff;border:3px solid;pointer-events:none}
  .arrow.left{background:#4ecdc4;border-color:#4ecdc4}
  .arrow.down{background:#ffe66d;border-color:#ffe66d;color:#000}
  .arrow.up{background:#ff6b6b;border-color:#ff6b6b}
  .arrow.right{background:#ff9f1c;border-color:#ff9f1c}
  /* overlays */
  #overlay{position:fixed;inset:0;background:rgba(0,0,0,.8);display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:200;display:none}
  #overlay h1{font-size:42px;margin-bottom:12px}
  #overlay button{background:#0f0;border:none;color:#000;padding:10px 18px;border-radius:8px;cursor:pointer;font-size:18px}
  /* effects */
  .hitEffect,.missEffect{position:absolute;width:80px;height:80px;border-radius:50%;pointer-events:none;z-index:210;animation:eff .35s forwards}
  .hitEffect{background:rgba(0,255,0,.42)}
  .missEffect{background:rgba(255,0,0,.42)}
  @keyframes eff{from{transform:scale(.6);opacity:1}to{transform:scale(2);opacity:0}}
  @media(max-width:900px){.targetWrap{width:70px;height:70px}.static{width:56px;height:56px;font-size:18px}}
</style>
</head>
<body>
  <div id="bg"></div>

  <div id="topHUD">
    <div class="health" id="playerHealth"><div class="fill" id="playerFill" style="width:100%"></div><div class="label">PLAYER</div></div>
    <div class="health" id="ubbaHealth"><div class="fill" id="ubbaFill" style="width:100%"></div><div class="label">UBBA</div></div>
  </div>

  <div id="controls">
    <div class="lane" id="playerLane">
      <div class="targetWrap"><div class="static left" data-type="left">A</div></div>
      <div class="targetWrap"><div class="static down" data-type="down">S</div></div>
      <div class="targetWrap"><div class="static up" data-type="up">W</div></div>
      <div class="targetWrap"><div class="static right" data-type="right">D</div></div>
    </div>

    <div class="lane" id="ubbaLane">
      <div class="targetWrap"><div class="static left" data-type="left">←</div></div>
      <div class="targetWrap"><div class="static down" data-type="down">↓</div></div>
      <div class="targetWrap"><div class="static up" data-type="up">↑</div></div>
      <div class="targetWrap"><div class="static right" data-type="right">→</div></div>
    </div>
  </div>

  <div id="centerUI">
    <div id="score">SCORE: 0</div>
    <div id="level">LEVEL 1</div>
    <div id="combo">COMBO: 0</div>
    <div id="botTurn">UBBA'S TURN</div>
  </div>

  <div id="characters">
    <div style="width:200px;text-align:center">
      <div class="char" id="you">YOU</div>
      <div class="hpRow"><div class="hpbar"><div class="fill" id="youBar" style="width:100%"></div></div></div>
    </div>
    <div style="width:200px;text-align:center">
      <div class="char" id="ubbaChar"></div>
      <div class="hpRow"><div class="hpbar"><div class="fill" id="ubbaBar" style="width:100%"></div></div></div>
    </div>
  </div>

  <div id="arrows"></div>

  <div id="overlay"><h1 id="resultTitle">RESULT</h1><button id="restartBtn">PLAY AGAIN</button></div>

<script>
/* Full working game script. Minimal comments (why-critical only). */

/* CONFIG */
const CONFIG = {
  baseSpeed: 3.2,       // px per frame base
  spawnGapBase: 600,    // ms between arrows (round 1/2)
  spawnGapExpert: 350,  // round 3 spawn gap
  hitTolerance: 56,     // px center-to-center tolerant window
  hpGain: 0.2,          // per successful hit
  hpLoss: 1,            // per miss or penalty
  rounds: 3,
  maxHP: 12,
  chordWindow: 220      // ms window to consider chord presses
};

/* STATE */
const state = {
  playing: false,
  round: 1,
  score: 0,
  combo: 0,
  maxCombo: 0,
  playerHP: CONFIG.maxHP,
  ubbaHP: CONFIG.maxHP,
  arrows: [],           // active arrows {el,type,side,y,hit,groupId,spawn}
  sequence: [],
  isBotPhase: true,
  ubbaTimers: [],
  recentKeyPresses: []
};

/* ELEMENTS */
const els = {
  arrows: document.getElementById('arrows'),
  playerLane: document.getElementById('playerLane'),
  ubbaLane: document.getElementById('ubbaLane'),
  score: document.getElementById('score'),
  level: document.getElementById('level'),
  combo: document.getElementById('combo'),
  botTurn: document.getElementById('botTurn'),
  playerFill: document.getElementById('playerFill'),
  ubbaFill: document.getElementById('ubbaFill'),
  overlay: document.getElementById('overlay'),
  resultTitle: document.getElementById('resultTitle'),
  restartBtn: document.getElementById('restartBtn'),
  youBar: document.getElementById('youBar'),
  ubbaBar: document.getElementById('ubbaBar')
};

/* key map (handles Arrow keys and WASD) */
const KEY_MAP = {
  a:'left', s:'down', w:'up', d:'right',
  arrowleft:'left', arrowdown:'down', arrowup:'up', arrowright:'right'
};

/* utility: compute static target rects for both sides */
function computeTargets() {
  return {
    player: {
      left: document.querySelector('#playerLane .static.left').getBoundingClientRect(),
      down: document.querySelector('#playerLane .static.down').getBoundingClientRect(),
      up: document.querySelector('#playerLane .static.up').getBoundingClientRect(),
      right: document.querySelector('#playerLane .static.right').getBoundingClientRect()
    },
    ubba: {
      left: document.querySelector('#ubbaLane .static.left').getBoundingClientRect(),
      down: document.querySelector('#ubbaLane .static.down').getBoundingClientRect(),
      up: document.querySelector('#ubbaLane .static.up').getBoundingClientRect(),
      right: document.querySelector('#ubbaLane .static.right').getBoundingClientRect()
    }
  };
}

/* create sequence; round3 has chords and many steps */
function makeSequence(round) {
  const base = ['left','down','up','right'];
  if (round < 3) {
    const len = 6 + (round-1)*4;
    return Array.from({length: len}, ()=> base[Math.floor(Math.random()*4)]);
  } else {
    const combos = [['up','right'],['left','up'],['down','right'],['left','down','up'],['right','up','left']];
    const len = 22;
    const s = [];
    for (let i=0;i<len;i++){
      if (Math.random() < 0.28) s.push(combos[Math.floor(Math.random()*combos.length)]);
      else s.push(base[Math.floor(Math.random()*4)]);
    }
    return s;
  }
}

/* spawn single arrow element, aligned to static center; append to #arrows container */
function spawnArrow(type, side, groupId=null) {
  const targets = computeTargets();
  const staticRect = (side === 'player') ? targets.player[type] : targets.ubba[type];
  if (!staticRect) return null;

  const arrow = document.createElement('div');
  arrow.className = 'arrow ' + type;
  arrow.textContent = {left:'←',down:'↓',up:'↑',right:'→'}[type] || '?';
  // center arrow left at static center
  const left = Math.round(staticRect.left + staticRect.width/2 - 35); // 35 = half arrow width
  arrow.style.left = left + 'px';
  // spawn bottom above characters area
  const charsRect = document.getElementById('characters').getBoundingClientRect();
  const spawnBottom = Math.max(20, window.innerHeight - charsRect.top + 12);
  arrow.style.bottom = spawnBottom + 'px';

  // color differentiate for clarity (not required)
  if (side === 'player') arrow.style.borderColor = 'rgba(255,255,255,0.18)';
  els.arrows.appendChild(arrow);

  const obj = { el: arrow, type, side, y: spawnBottom, hit: false, groupId, spawn: performance.now() };
  state.arrows.push(obj);

  if (side === 'ubba') scheduleUbbaAuto(obj, staticRect);
  return obj;
}

/* schedule ubba flash + removal (handles groupId by scheduling per arrow; group removal handled on hit) */
function scheduleUbbaAuto(arrowObj, staticRect) {
  // compute arrow center Y now and static center Y
  const arrowRect = arrowObj.el.getBoundingClientRect();
  const arrowCenterY = arrowRect.top + arrowRect.height/2;
  const staticCenterY = staticRect.top + staticRect.height/2;
  const distance = arrowCenterY - staticCenterY; // px to travel upward

  const pxPerMs = currentSpeed() / (1000/60); // speed px/frame -> px/ms
  const timeMs = Math.max(0, distance / pxPerMs);

  const preFlash = 70;
  const flashTimer = setTimeout(()=> {
    flashStatic('ubba', arrowObj.type, 120);
  }, Math.max(0, timeMs - preFlash));
  const hitTimer = setTimeout(() => {
    if (!arrowObj.hit) {
      // if group: remove group members
      if (arrowObj.groupId !== null) {
        const members = state.arrows.filter(a => a.groupId === arrowObj.groupId && !a.hit);
        members.forEach(m => { m.hit = true; if (m.el && m.el.parentElement) m.el.remove(); });
        state.arrows = state.arrows.filter(a => a.groupId !== arrowObj.groupId);
      } else {
        arrowObj.hit = true;
        if (arrowObj.el && arrowObj.el.parentElement) arrowObj.el.remove();
        state.arrows = state.arrows.filter(a => a !== arrowObj);
      }
    }
  }, Math.max(0, timeMs + 12));

  state.ubbaTimers.push(flashTimer, hitTimer);
}

/* flash static key for given side and type; color 'green' or 'red' */
function flashStatic(side, type, ms=140, color='green') {
  const container = (side === 'player') ? document.getElementById('playerLane') : document.getElementById('ubbaLane');
  const el = container.querySelector('.static.' + type);
  if (!el) return;
  const cls = (color === 'red') ? 'fail' : 'active';
  el.classList.add(cls);
  setTimeout(()=> el.classList.remove(cls), ms);
}

/* get current speed based on round */
function currentSpeed() {
  return CONFIG.baseSpeed * (state.round === 3 ? 2.0 : 1.0);
}

/* main animation loop */
function loop() {
  if (!state.playing) return;
  for (let i = state.arrows.length - 1; i >= 0; i--) {
    const a = state.arrows[i];
    if (a.hit) { state.arrows.splice(i,1); continue; }
    a.y += currentSpeed();
    a.el.style.bottom = a.y + 'px';
    const rect = a.el.getBoundingClientRect();
    if (rect.bottom < 0) {
      // arrow left top -> if player's arrow then it's a miss
      if (a.side === 'player' && !a.hit) {
        a.hit = true;
        flashStatic('player', a.type, 220, 'red');
        state.playerHP = Math.max(0, state.playerHP - CONFIG.hpLoss);
        state.combo = 0;
        showMissEffect(a.el);
        updateUI();
      }
      // remove DOM and state
      if (a.el && a.el.parentElement) a.el.remove();
      state.arrows.splice(i,1);
    }
  }
  // ensure completion check so rounds don't soft-lock
  checkRoundCompletion();
  requestAnimationFrame(loop);
}

/* show small miss/hit circle effect */
function showHitEffect(el) {
  try {
    const r = el.getBoundingClientRect();
    const e = document.createElement('div');
    e.className = 'hitEffect';
    e.style.left = (r.left + r.width/2 - 40) + 'px';
    e.style.top = (r.top + r.height/2 - 40) + 'px';
    document.body.appendChild(e);
    setTimeout(()=> e.remove(), 380);
  } catch(e){}
}
function showMissEffect(el) {
  try {
    const r = el.getBoundingClientRect();
    const e = document.createElement('div');
    e.className = 'missEffect';
    e.style.left = (r.left + r.width/2 - 40) + 'px';
    e.style.top = (r.top + r.height/2 - 40) + 'px';
    document.body.appendChild(e);
    setTimeout(()=> e.remove(), 380);
  } catch(e){}
}

/* input handling (player) — chord detection window maintained in state.recentKeyPresses */
document.addEventListener('keydown', (evt) => {
  if (!state.playing || state.isBotPhase) return;
  const key = evt.key.toLowerCase();
  if (!(key in KEY_MAP)) return;
  const now = performance.now();
  state.recentKeyPresses.push({ type: KEY_MAP[key], time: now });
  // purge old
  while (state.recentKeyPresses.length && now - state.recentKeyPresses[0].time > CONFIG.chordWindow) state.recentKeyPresses.shift();
  flashStatic('player', KEY_MAP[key], 140, 'green');
  attemptPlayerHit(KEY_MAP[key]);
});

/* Attempt hit (supports chord groups): */
function attemptPlayerHit(pressedType) {
  const targets = computeTargets().player;
  const candidates = state.arrows.filter(a => a.side === 'player' && !a.hit);
  if (candidates.length === 0) {
    flashStatic('player', pressedType, 120, 'red');
    failPenalty();
    return;
  }
  // find near arrows (within tolerance to their static center)
  const near = [];
  for (const a of candidates) {
    const rect = a.el.getBoundingClientRect();
    const centerA = rect.top + rect.height/2;
    const centerT = (targets[a.type].top + targets[a.type].height/2);
    if (Math.abs(centerA - centerT) <= CONFIG.hitTolerance) near.push(a);
  }
  if (near.length === 0) {
    flashStatic('player', pressedType, 120, 'red');
    failPenalty();
    return;
  }
  // group by vertical band (coarse)
  const groups = {};
  for (const a of near) {
    const rect = a.el.getBoundingClientRect();
    const center = Math.round((rect.top + rect.height/2)/8)*8;
    groups[center] = groups[center] || [];
    groups[center].push(a);
  }
  // pick group containing pressedType if available, else the largest group
  let chosen = null;
  for (const k in groups) {
    if (groups[k].some(x => x.type === pressedType)) { chosen = groups[k]; break; }
  }
  if (!chosen) {
    const keys = Object.keys(groups);
    chosen = groups[keys[0]];
  }
  // required types for this group
  const required = [...new Set(chosen.map(a => a.type))];
  const pressedSet = new Set(state.recentKeyPresses.map(p => p.type));
  const allPressed = required.every(r => pressedSet.has(r));
  if (allPressed) {
    // success: remove chosen group arrows and apply scoring
    chosen.forEach(a => { a.hit = true; if (a.el && a.el.parentElement) a.el.remove(); });
    state.arrows = state.arrows.filter(a => !a.hit);
    state.score += 100 * Math.max(1, required.length);
    state.combo++;
    state.maxCombo = Math.max(state.maxCombo, state.combo);
    state.playerHP = Math.min(CONFIG.maxHP, state.playerHP + CONFIG.hpGain);
    state.ubbaHP = Math.max(0, state.ubbaHP - CONFIG.hpLoss * required.length);
    updateUI();
  } else {
    flashStatic('player', pressedType, 140, 'red');
    failPenalty();
  }
  checkRoundCompletion();
}

/* penalty helper */
function failPenalty() {
  state.playerHP = Math.max(0, state.playerHP - CONFIG.hpLoss);
  state.combo = 0;
  updateUI();
}

/* spawn sequence for player (chords supported) */
function spawnPlayerSequence(seq) {
  let i = 0;
  const gap = (state.round === 3) ? CONFIG.spawnGapExpert : CONFIG.spawnGapBase;
  const idGen = (() => { let id = 0; return () => ++id; })();
  const t = setInterval(() => {
    if (i >= seq.length) { clearInterval(t); return; }
    const step = seq[i];
    if (Array.isArray(step)) {
      const gid = idGen();
      step.forEach(st => spawnArrow(st, 'player', gid));
    } else spawnArrow(step, 'player', null);
    i++;
  }, gap);
}

/* show ubba sequence (spawn ubba arrows), then let player spawn */
function showUbbaSequence(seq, done) {
  state.isBotPhase = true;
  els.botTurn.style.display = 'block';
  cleanupRound();
  let i = 0;
  const gap = (state.round === 3) ? CONFIG.spawnGapExpert : CONFIG.spawnGapBase;
  const idGen = (() => { let id = 0; return () => ++id; })();
  const t = setInterval(() => {
    if (i >= seq.length) { clearInterval(t); setTimeout(()=>{ state.isBotPhase = false; els.botTurn.style.display = 'none'; done(); }, 520); return; }
    const step = seq[i];
    if (Array.isArray(step)) {
      const gid = idGen();
      step.forEach(st => spawnArrow(st, 'ubba', gid));
    } else spawnArrow(step, 'ubba', null);
    i++;
  }, gap);
}

/* check completion: when player phase and no player arrows remain -> advance round or end */
function checkRoundCompletion() {
  const playerRemain = state.arrows.some(a => a.side === 'player' && !a.hit);
  if (!state.isBotPhase && !playerRemain) {
    // advance or end
    state.playing = false;
    if (state.round < CONFIG.rounds && state.playerHP > 0 && state.ubbaHP > 0) {
      state.round++;
      updateUI();
      setTimeout(() => { startRound(state.round); }, 900);
    } else {
      finishGame();
    }
  }
}

/* cleanup between sequences */
function cleanupRound() {
  state.ubbaTimers.forEach(t => clearTimeout(t));
  state.ubbaTimers = [];
  state.arrows.forEach(a => { try { if (a.el && a.el.parentElement) a.el.remove(); } catch(e){} });
  state.arrows = [];
  state.recentKeyPresses = [];
}

/* start a round: generate seq and show ubba then spawn player */
function startRound(roundNum) {
  state.sequence = makeSequence(roundNum);
  state.isBotPhase = true;
  els.botTurn.style.display = 'block';
  cleanupRound();
  showUbbaSequence(state.sequence, () => {
    spawnPlayerSequence(state.sequence);
    state.playing = true;
    requestAnimationFrame(loop);
  });
}

/* finish game */
function finishGame() {
  state.playing = false;
  cleanupRound();
  els.overlay.style.display = 'flex';
  els.resultTitle.textContent = (state.playerHP > state.ubbaHP) ? 'YOU WIN!' : 'YOU LOSE!';
  els.resultTitle.style.color = (state.playerHP > state.ubbaHP) ? '#1df53a' : '#ff4b4b';
}

/* update UI visuals (HP scaled to 12) */
function updateUI() {
  els.score.textContent = `SCORE: ${state.score}`;
  els.combo.style.display = state.combo > 1 ? 'block' : 'none';
  els.combo.textContent = `COMBO: ${state.combo}`;
  els.level.textContent = `LEVEL ${state.round}`;
  els.playerFill.style.width = `${(state.playerHP / CONFIG.maxHP) * 100}%`;
  els.ubbaFill.style.width = `${(state.ubbaHP / CONFIG.maxHP) * 100}%`;
  els.youBar.style.width = `${(state.playerHP / CONFIG.maxHP) * 100}%`;
  els.ubbaBar.style.width = `${(state.ubbaHP / CONFIG.maxHP) * 100}%`;
}

/* start game */
function startGame() {
  state.playing = false;
  state.round = 1;
  state.score = 0; state.combo = 0; state.maxCombo = 0;
  state.playerHP = CONFIG.maxHP; state.ubbaHP = CONFIG.maxHP;
  updateUI();
  els.overlay.style.display = 'none';
  startRound(1);
}

/* wire restart */
els.restartBtn.addEventListener('click', () => {
  // reset and start
  state.playing = false;
  els.overlay.style.display = 'none';
  startGame();
});

/* expose a lightweight manual start when file loads */
window.addEventListener('load', ()=> {
  // small delay then start automatically for convenience
  setTimeout(()=> startGame(), 500);
});

/* ensure target down keys show white text (fix earlier black text bug) */
document.querySelectorAll('.static.down').forEach(s => s.style.color = '#fff');

</script>
</body>
</html>
